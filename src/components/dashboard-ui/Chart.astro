---
/**
 * Chart - Chart visualization wrapper component
 *
 * @description
 * A wrapper component for Chart.js that provides theme-aware chart
 * visualizations with support for line, bar, and area charts.
 *
 * Features:
 * - Support for line, bar, and area chart types
 * - Theme-aware colors for light/dark mode
 * - Responsive sizing
 * - Configurable height
 * - Proper ARIA labels for accessibility
 * - Client-side initialization
 *
 * @example
 * ```astro
 * <Chart
 *   type="line"
 *   data={{
 *     labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
 *     datasets: [{
 *       label: 'Sales',
 *       data: [12, 19, 3, 5, 2, 3, 9],
 *       color: '#6366f1'
 *     }]
 *   }}
 *   height={300}
 * />
 * ```
 */

interface Dataset {
  label: string;
  data: number[];
  color?: string;
}

interface ChartData {
  labels: string[];
  datasets: Dataset[];
}

interface Props {
  type: 'line' | 'bar' | 'area';
  data: ChartData;
  height?: number;
  ariaLabel?: string;
}

const { type, data, height = 300, ariaLabel } = Astro.props;

// Generate a unique ID for this chart instance
const chartId = `chart-${Math.random().toString(36).substring(2, 11)}`;

// Serialize data for client-side script
const chartData = JSON.stringify(data);
const chartType = type === 'area' ? 'line' : type;
---

<div class="chart-container" style={`height: ${height}px`}>
  <canvas
    id={chartId}
    data-chart-type={chartType}
    data-chart-data={chartData}
    data-is-area={type === 'area'}
    role="img"
    aria-label={ariaLabel ||
      `${type} chart showing ${data.datasets.map((d) => d.label).join(', ')}`}></canvas>
</div>

<script>
  import Chart from 'chart.js/auto';
  import type { TooltipItem } from 'chart.js';

  interface ThemeColors {
    isDark: boolean;
    text: string;
    textMuted: string;
    border: string;
    grid: string;
    tooltipBg: string;
    tooltipBorder: string;
    chartColors: string[];
  }

  interface DatasetInput {
    label: string;
    data: number[];
    color?: string;
  }

  interface ChartDataInput {
    labels: string[];
    datasets: DatasetInput[];
  }

  // Helper function to convert hex to rgba
  function hexToRgba(hex: string, alpha: number): string {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // Get theme-aware colors
  function getThemeColors(): ThemeColors {
    // Priority: explicit dark class > localStorage > system preference
    const isDark = document.documentElement.classList.contains('dark');

    return {
      isDark,
      text: isDark ? '#f3f4f6' : '#111827',
      textMuted: isDark ? '#9ca3af' : '#6b7280',
      border: isDark ? '#374151' : '#e5e7eb',
      grid: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.15)',
      tooltipBg: isDark ? 'rgba(31, 41, 55, 0.95)' : 'rgba(255, 255, 255, 0.95)',
      tooltipBorder: isDark ? 'rgba(75, 85, 99, 1)' : 'rgba(229, 231, 235, 1)',
      chartColors: isDark
        ? [
            '#8b5cf6', // Purple
            '#ec4899', // Pink
            '#10b981', // Green
            '#f59e0b', // Amber
            '#3b82f6', // Blue
            '#ef4444', // Red
          ]
        : [
            '#7c3aed', // Purple
            '#db2777', // Pink
            '#059669', // Green
            '#d97706', // Amber
            '#2563eb', // Blue
            '#dc2626', // Red
          ],
    };
  }

  function initializeChart(canvas: HTMLCanvasElement) {
    const chartType = canvas.dataset.chartType as 'line' | 'bar';
    const chartData = canvas.dataset.chartData;
    const isArea = canvas.dataset.isArea === 'true';

    if (!chartData) return;

    const data: ChartDataInput = JSON.parse(chartData);
    let chartInstance: Chart | undefined = undefined;

    function createChart() {
      const colors = getThemeColors();

      // Prepare datasets with colors and styling
      const datasets = data.datasets.map((dataset: DatasetInput, index: number) => {
        const color = dataset.color || colors.chartColors[index % colors.chartColors.length];

        const baseDataset = {
          label: dataset.label,
          data: dataset.data,
          borderColor: color,
          backgroundColor: isArea ? hexToRgba(color, colors.isDark ? 0.3 : 0.2) : color,
          borderWidth: 2.5,
          tension: 0.4,
          fill: isArea ? true : undefined,
          pointBackgroundColor: isArea ? (colors.isDark ? '#fff' : color) : undefined,
          pointBorderColor: isArea ? (colors.isDark ? color : '#fff') : undefined,
          pointBorderWidth: isArea ? 2 : undefined,
          pointRadius: isArea ? 4 : undefined,
          pointHoverRadius: isArea ? 6 : undefined,
          pointHoverBackgroundColor: isArea ? color : undefined,
          pointHoverBorderColor: isArea ? '#fff' : undefined,
          pointHoverBorderWidth: isArea ? 3 : undefined,
          borderRadius: chartType === 'bar' ? 4 : undefined,
          borderSkipped: chartType === 'bar' ? false : undefined,
        };

        return baseDataset;
      });

      // Create or update chart
      if (chartInstance) {
        // Update existing chart
        chartInstance.data.datasets = datasets as never;
        if (chartInstance.options.plugins?.legend?.labels) {
          chartInstance.options.plugins.legend.labels.color = colors.text;
        }
        if (chartInstance.options.plugins?.tooltip) {
          chartInstance.options.plugins.tooltip.backgroundColor = colors.tooltipBg;
          chartInstance.options.plugins.tooltip.titleColor = colors.text;
          chartInstance.options.plugins.tooltip.bodyColor = colors.text;
          chartInstance.options.plugins.tooltip.borderColor = colors.tooltipBorder;
        }
        if (chartInstance.options.scales?.x?.ticks) {
          chartInstance.options.scales.x.ticks.color = colors.textMuted;
        }
        if (chartInstance.options.scales?.x?.grid) {
          chartInstance.options.scales.x.grid.color = colors.grid;
        }
        if (chartInstance.options.scales?.y?.ticks) {
          chartInstance.options.scales.y.ticks.color = colors.textMuted;
        }
        if (chartInstance.options.scales?.y?.grid) {
          chartInstance.options.scales.y.grid.color = colors.grid;
        }
        chartInstance.update('none'); // Update without animation
      } else {
        // Create new chart
        chartInstance = new Chart(canvas, {
          type: chartType,
          data: {
            labels: data.labels,
            datasets: datasets as never,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: data.datasets.length > 1,
                position: 'top',
                align: 'end',
                labels: {
                  color: colors.text,
                  usePointStyle: true,
                  padding: 16,
                  font: {
                    size: 12,
                    family: 'system-ui, -apple-system, sans-serif',
                  },
                },
              },
              tooltip: {
                backgroundColor: colors.tooltipBg,
                titleColor: colors.text,
                bodyColor: colors.text,
                borderColor: colors.tooltipBorder,
                borderWidth: 1,
                padding: 12,
                displayColors: true,
                boxPadding: 6,
                usePointStyle: true,
                cornerRadius: 8,
                titleFont: {
                  size: 13,
                  weight: 600,
                  family: 'system-ui, -apple-system, sans-serif',
                },
                bodyFont: {
                  size: 13,
                  family: 'system-ui, -apple-system, sans-serif',
                },
                callbacks: {
                  label: function (context: TooltipItem<'line' | 'bar'>) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.y !== null) {
                      label += context.parsed.y.toLocaleString();
                    }
                    return label;
                  },
                },
              },
            },
            scales: {
              x: {
                grid: {
                  display: true,
                  color: colors.grid,
                  drawOnChartArea: true,
                  drawTicks: false,
                },
                ticks: {
                  color: colors.textMuted,
                  font: {
                    size: 12,
                    family: 'system-ui, -apple-system, sans-serif',
                  },
                  padding: 8,
                },
                border: {
                  display: false,
                },
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: colors.grid,
                  drawTicks: false,
                },
                ticks: {
                  color: colors.textMuted,
                  font: {
                    size: 12,
                    family: 'system-ui, -apple-system, sans-serif',
                  },
                  padding: 8,
                  callback: function (value: string | number) {
                    if (typeof value === 'number') {
                      return value.toLocaleString();
                    }
                    return value;
                  },
                },
                border: {
                  display: false,
                },
              },
            },
            interaction: {
              intersect: false,
              mode: 'index',
            },
          },
        });
      }
    }

    // Initial chart creation
    createChart();

    // Watch for theme changes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          createChart();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class'],
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (chartInstance) {
        chartInstance.destroy();
      }
      observer.disconnect();
    });

    // Store chart instance and observer for cleanup
    interface CanvasWithChart extends HTMLCanvasElement {
      __chartInstance?: Chart;
      __chartObserver?: MutationObserver;
    }

    (canvas as CanvasWithChart).__chartInstance = chartInstance;
    (canvas as CanvasWithChart).__chartObserver = observer;
  }

  // Initialize all charts on the page
  function initAllCharts() {
    interface CanvasWithChart extends HTMLCanvasElement {
      __chartInstance?: Chart;
      __chartObserver?: MutationObserver;
    }

    const canvases = document.querySelectorAll<HTMLCanvasElement>('canvas[data-chart-type]');
    canvases.forEach((canvas) => {
      const canvasWithChart = canvas as CanvasWithChart;

      // Cleanup existing chart if any
      if (canvasWithChart.__chartInstance) {
        canvasWithChart.__chartInstance.destroy();
      }
      if (canvasWithChart.__chartObserver) {
        canvasWithChart.__chartObserver.disconnect();
      }

      initializeChart(canvas);
    });
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAllCharts);
  } else {
    initAllCharts();
  }

  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', initAllCharts);
</script>

<style>
  .chart-container {
    position: relative;
    width: 100%;
    min-height: 200px;
  }

  canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
  }

  /* Ensure proper sizing on mobile */
  @media (max-width: 640px) {
    .chart-container {
      min-height: 250px;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    canvas {
      animation: none !important;
    }
  }
</style>
