---
/**
 * Modal - Dialog/modal component
 *
 * @description
 * A modal dialog component with backdrop overlay, keyboard support,
 * and focus trap. Supports configurable sizes and slots for content
 * and footer.
 *
 * Features:
 * - Backdrop overlay
 * - Close button
 * - Keyboard support (ESC to close)
 * - Focus trap when modal is open
 * - Configurable sizes (sm, md, lg, xl)
 * - Slots for content and footer
 * - Accessible with proper ARIA attributes
 *
 * @example
 * ```astro
 * <Modal id="confirm-delete" title="Confirm Deletion" size="sm">
 *   <p>Are you sure you want to delete this item?</p>
 *   <div slot="footer">
 *     <button>Cancel</button>
 *     <button>Delete</button>
 *   </div>
 * </Modal>
 * ```
 *
 * @example Opening the modal via JavaScript
 * ```javascript
 * window.openModal('confirm-delete');
 * window.closeModal('confirm-delete');
 * ```
 */

import { Icon } from 'astro-icon/components';

interface Props {
  /** Unique identifier for the modal */
  id: string;
  /** Modal title displayed in header */
  title: string;
  /** Modal size variant */
  size?: 'sm' | 'md' | 'lg' | 'xl';
}

const { id, title, size = 'md' } = Astro.props;

const sizeClasses = {
  sm: 'modal-size-sm',
  md: 'modal-size-md',
  lg: 'modal-size-lg',
  xl: 'modal-size-xl',
};
---

<div
  id={id}
  class="modal-overlay hidden"
  role="dialog"
  aria-modal="true"
  aria-labelledby={`${id}-title`}
  data-modal
>
  <!-- Backdrop -->
  <div class="modal-backdrop" data-modal-backdrop></div>

  <!-- Modal Container -->
  <div class="modal-container">
    <!-- Modal Content -->
    <div class:list={['modal-content', sizeClasses[size]]} data-modal-content>
      <!-- Header -->
      <div class="modal-header">
        <h2 id={`${id}-title`} class="modal-title">{title}</h2>
        <button type="button" class="modal-close-button" aria-label="Close modal" data-modal-close>
          <Icon name="lucide:x" class="w-5 h-5" />
        </button>
      </div>

      <!-- Body -->
      <div class="modal-body">
        <slot />
      </div>

      <!-- Footer (optional) -->
      {
        Astro.slots.has('footer') && (
          <div class="modal-footer">
            <slot name="footer" />
          </div>
        )
      }
    </div>
  </div>
</div>

<style>
  /* Modal Overlay */
  .modal-overlay {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    opacity: 0;
    transition:
      opacity 200ms ease,
      visibility 200ms ease;
    visibility: hidden;
  }

  .modal-overlay:not(.hidden) {
    opacity: 1;
    visibility: visible;
  }

  /* Backdrop */
  .modal-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(2px);
  }

  /* Modal Container */
  .modal-container {
    position: relative;
    width: 100%;
    max-height: calc(100vh - 2rem);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Modal Content */
  .modal-content {
    position: relative;
    width: 100%;
    max-height: calc(100vh - 2rem);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    box-shadow:
      0 20px 25px -5px rgb(0 0 0 / 0.1),
      0 8px 10px -6px rgb(0 0 0 / 0.1);
    display: flex;
    flex-direction: column;
    transform: scale(0.95);
    transition: transform 200ms ease;
  }

  .modal-overlay:not(.hidden) .modal-content {
    transform: scale(1);
  }

  /* Size Variants */
  .modal-size-sm {
    max-width: 400px;
  }

  .modal-size-md {
    max-width: 500px;
  }

  .modal-size-lg {
    max-width: 700px;
  }

  .modal-size-xl {
    max-width: 900px;
  }

  /* Modal Header */
  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.5rem;
    border-bottom: 1px solid var(--color-border);
  }

  .modal-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--color-text);
    margin: 0;
  }

  .modal-close-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    border-radius: var(--radius-md);
    color: var(--color-text-muted);
    transition: all 150ms ease;
    cursor: pointer;
  }

  .modal-close-button:hover {
    background: var(--color-background);
    color: var(--color-text);
  }

  .modal-close-button:focus {
    outline: none;
  }

  .modal-close-button:focus-visible {
    outline: 2px solid var(--color-primary);
    outline-offset: 2px;
  }

  /* Modal Body */
  .modal-body {
    padding: 1.5rem;
    overflow-y: auto;
    flex: 1;
  }

  /* Modal Footer */
  .modal-footer {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 0.75rem;
    padding: 1rem 1.5rem;
    border-top: 1px solid var(--color-border);
    background: var(--color-surface);
    border-bottom-left-radius: var(--radius-lg);
    border-bottom-right-radius: var(--radius-lg);
  }

  /* Responsive adjustments */
  @media (max-width: 640px) {
    .modal-overlay {
      padding: 0;
    }

    .modal-container {
      max-height: 100vh;
    }

    .modal-content {
      max-height: 100vh;
      border-radius: 0;
    }

    .modal-size-sm,
    .modal-size-md,
    .modal-size-lg,
    .modal-size-xl {
      max-width: 100%;
    }

    .modal-header {
      padding: 1.25rem;
    }

    .modal-body {
      padding: 1.25rem;
    }

    .modal-footer {
      padding: 0.75rem 1.25rem;
    }
  }

  /* Respect reduced motion preference */
  @media (prefers-reduced-motion: reduce) {
    .modal-overlay,
    .modal-content,
    .modal-close-button {
      transition: none;
    }
  }

  /* Prevent body scroll when modal is open */
  :global(body.modal-open) {
    overflow: hidden;
  }
</style>

<script>
  /**
   * Modal Client-Side Functionality
   *
   * Manages:
   * - Opening and closing modals
   * - Keyboard support (ESC to close)
   * - Focus trap when modal is open
   * - Click backdrop to close
   * - Body scroll lock
   */

  interface ModalState {
    isOpen: boolean;
    previousFocus: HTMLElement | null;
    focusableElements: HTMLElement[];
    firstFocusable: HTMLElement | null;
    lastFocusable: HTMLElement | null;
  }

  const modalStates = new Map<string, ModalState>();

  /**
   * Get all focusable elements within a container
   */
  function getFocusableElements(container: HTMLElement): HTMLElement[] {
    const selector =
      'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])';
    return Array.from(container.querySelectorAll(selector));
  }

  /**
   * Open a modal by ID
   */
  function openModal(modalId: string) {
    const modal = document.getElementById(modalId);
    if (!modal || !modal.hasAttribute('data-modal')) return;

    const modalContent = modal.querySelector('[data-modal-content]') as HTMLElement;
    if (!modalContent) return;

    // Store current focus
    const previousFocus = document.activeElement as HTMLElement;

    // Get focusable elements
    const focusableElements = getFocusableElements(modalContent);
    const firstFocusable = focusableElements[0] || null;
    const lastFocusable = focusableElements[focusableElements.length - 1] || null;

    // Store modal state
    modalStates.set(modalId, {
      isOpen: true,
      previousFocus,
      focusableElements,
      firstFocusable,
      lastFocusable,
    });

    // Show modal
    modal.classList.remove('hidden');
    document.body.classList.add('modal-open');

    // Focus first focusable element
    setTimeout(() => {
      if (firstFocusable) {
        firstFocusable.focus();
      }
    }, 50);
  }

  /**
   * Close a modal by ID
   */
  function closeModal(modalId: string) {
    const modal = document.getElementById(modalId);
    if (!modal || !modal.hasAttribute('data-modal')) return;

    const state = modalStates.get(modalId);

    // Hide modal
    modal.classList.add('hidden');
    document.body.classList.remove('modal-open');

    // Restore focus
    if (state?.previousFocus) {
      state.previousFocus.focus();
    }

    // Clear state
    modalStates.delete(modalId);
  }

  /**
   * Handle focus trap within modal
   */
  function handleFocusTrap(event: KeyboardEvent, modalId: string) {
    if (event.key !== 'Tab') return;

    const state = modalStates.get(modalId);
    if (!state || !state.firstFocusable || !state.lastFocusable) return;

    // Shift + Tab
    if (event.shiftKey) {
      if (document.activeElement === state.firstFocusable) {
        event.preventDefault();
        state.lastFocusable.focus();
      }
    }
    // Tab
    else {
      if (document.activeElement === state.lastFocusable) {
        event.preventDefault();
        state.firstFocusable.focus();
      }
    }
  }

  /**
   * Initialize all modals on the page
   */
  function initModals() {
    const modals = document.querySelectorAll('[data-modal]');

    modals.forEach((modal) => {
      const modalId = modal.id;
      if (!modalId) return;

      // Close button
      const closeButton = modal.querySelector('[data-modal-close]');
      if (closeButton) {
        closeButton.addEventListener('click', () => closeModal(modalId));
      }

      // Backdrop click
      const backdrop = modal.querySelector('[data-modal-backdrop]');
      if (backdrop) {
        backdrop.addEventListener('click', () => closeModal(modalId));
      }

      // Keyboard events
      modal.addEventListener('keydown', (event: Event) => {
        const keyEvent = event as KeyboardEvent;
        const state = modalStates.get(modalId);
        if (!state?.isOpen) return;

        // ESC to close
        if (keyEvent.key === 'Escape') {
          keyEvent.preventDefault();
          closeModal(modalId);
        }

        // Focus trap
        handleFocusTrap(keyEvent, modalId);
      });
    });
  }

  // Expose global functions for opening/closing modals
  declare global {
    interface Window {
      openModal: (modalId: string) => void;
      closeModal: (modalId: string) => void;
    }
  }

  window.openModal = openModal;
  window.closeModal = closeModal;

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initModals);
  } else {
    initModals();
  }

  // Re-initialize on Astro page transitions (if using View Transitions)
  document.addEventListener('astro:page-load', initModals);
</script>
